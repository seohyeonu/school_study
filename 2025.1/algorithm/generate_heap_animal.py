import math

def read_numbers(filename):
    """
    numbers.txt 파일을 읽어와서:
    - 첫 번째 줄: 정수 n (노드 개수)
    - 그다음 n개의 줄: 한 줄에 하나씩 노드 값을 레벨 순서대로 저장
    """
    with open(filename, 'r') as f:
        lines = [line.strip() for line in f if line.strip()]
    if not lines:
        raise ValueError("numbers.txt가 비어 있습니다.")
    
    n = int(lines[0])
    values = [int(line) for line in lines[1:1 + n]]
    if len(values) < n:
        raise ValueError(f"첫 줄에 {n}개의 노드를 적었으나, 실제로 읽힌 값이 {len(values)}개입니다.")
    return n, values

def find_violations(values):
    """
    최대 힙(max-heap) 성질을 위반하는 자식 노드 인덱스를 찾아서 반환.
    - 인덱스 i에 대해 왼쪽 자식 L=2*i+1, 오른쪽 자식 R=2*i+2를 검사
    - 부모 값 < 자식 값인 경우, 그 자식 인덱스를 위반 노드로 추가
    """
    n = len(values)
    violations = set()
    for i in range(n):
        left = 2 * i + 1
        right = 2 * i + 2
        if left < n and values[i] < values[left]:
            violations.add(left)
        if right < n and values[i] < values[right]:
            violations.add(right)
    return sorted(violations)

def compute_positions(n, horizontal_gap=60, vertical_gap=100, top_margin=50):
    """
    각 노드 i에 대해 좌표를 계산.
    - 마지막 레벨(리프)의 노드 개수를 구해서, 그 개수만큼 horizontal_gap 간격으로 배치.
    - width = (num_last_level_nodes + 1) * horizontal_gap
    - 각 레벨 ℓ: count_in_level = 2^ℓ
      - x_spacing = width / (count_in_level + 1)
      - x = (index_in_level + 1) * x_spacing
      - y = top_margin + (ℓ * vertical_gap)
    - 중앙 정렬을 위해 모든 x좌표를 shift 처리
    - 반환값: [(x, y, lvl, total_levels), ...] 형태의 리스트
    """
    if n <= 0:
        return []
    
    # 1) 전체 레벨 수 및 마지막 레벨 노드 개수 계산
    max_level = math.floor(math.log2(n))            # 0부터 시작하는 레벨 번호
    total_levels = max_level + 1                     # 실제 레벨 개수
    first_index_of_last = 2 ** max_level - 1         # 마지막 레벨이 시작하는 인덱스
    num_last = n - first_index_of_last               # 마지막 레벨(리프) 노드 개수

    # 2) 전체 폭(width)을 num_last+1 * horizontal_gap 으로 설정
    width = (num_last + 1) * horizontal_gap

    positions = [None] * n
    for i in range(n):
        lvl = math.floor(math.log2(i + 1))          # 0-based 레벨
        count_in_level = 2 ** lvl                    # 해당 레벨에 속하는 노드 개수
        index_in_level = i - (2 ** lvl - 1)          # 해당 레벨 내에서 0-based 순서
        
        x_spacing = width / (count_in_level + 1)
        x = int((index_in_level + 1) * x_spacing)
        y = top_margin + (lvl * vertical_gap)
        positions[i] = (x, y, lvl, total_levels)
    
    # 3) 현재 positions의 x값 범위를 구하고, 중앙 정렬을 위해 shift 계산
    xs = [pos[0] for pos in positions]
    min_x, max_x = min(xs), max(xs)
    current_center = (min_x + max_x) / 2
    desired_center = width / 2
    shift_x = desired_center - current_center

    # 4) shift만큼 각 x에 보정 적용
    for i in range(n):
        x, y, lvl, tl = positions[i]
        positions[i] = (int(x + shift_x), y, lvl, tl)

    return positions

def generate_animal_script(n, values, violations, positions, output_file):
    """
    Animal Script(.asu) 파일을 생성.
    - 노드: 원(circle) 테두리만 그리고, 내부에 text로 값 표시
      - 정상 노드: 테두리 검은색, 텍스트 검은색
      - 위반 노드: 테두리 빨간색, 텍스트 빨간색
    - 부모→자식 연결선(line): 기본 검은 선
    - depth 값: total_levels - lvl 으로 설정 (상이한 레벨 겹침 순서 조절)
    """
    with open(output_file, 'w') as f:
        # 1) 헤더
        f.write('%Animal 2.0\n')
        f.write('title "Heap Animation"\n')
        f.write('author "Generated by Python"\n\n')
        
        # 2) 각 노드: circle + text
        for i in range(n):
            x, y, lvl, total_levels = positions[i]
            depth = total_levels - lvl  # 상위 레벨 노드가 앞쪽에 오도록
            
            if i in violations:
                # 힙 위반 노드: 테두리 빨간색, 텍스트 빨간색
                f.write(f'circle "c{i}" ({x},{y}) radius 20 color red depth {depth}\n')
                f.write(f'text "t{i}" "{values[i]}" ({x},{y}) color red depth {depth}\n')
            else:
                # 정상 노드: 테두리 검은색, 텍스트 검은색
                f.write(f'circle "c{i}" ({x},{y}) radius 20 color black depth {depth}\n')
                f.write(f'text "t{i}" "{values[i]}" ({x},{y}) color black depth {depth}\n')
        f.write('\n')
        
        # 3) 부모→자식 연결선(line)
        for i in range(n):
            x1, y1, lvl1, total_levels1 = positions[i]
            left = 2 * i + 1
            right = 2 * i + 2
            line_depth = total_levels1 - lvl1 + 1  # 선이 원보다 약간 뒤로 가도록 조절
            if left < n:
                x2, y2, _, _ = positions[left]
                f.write(f'line "l{i}_{left}" ({x1},{y1}) ({x2},{y2}) depth {line_depth}\n')
            if right < n:
                x2, y2, _, _ = positions[right]
                f.write(f'line "l{i}_{right}" ({x1},{y1}) ({x2},{y2}) depth {line_depth}\n')
        f.write('\n')
        
        # 4) 애니메이션 정지 (pause)
        f.write('pause 300\n')

if __name__ == "__main__":
    # 1) numbers.txt 읽기
    n, values = read_numbers("number31.txt")
    print(f"읽은 노드 개수: {n}, 값 리스트: {values}")
    
    # 2) 힙 속성 위반 인덱스 찾기 (자식 노드가 부모보다 클 때 그 자식을 위반으로 표시)
    violations = find_violations(values)
    print(f"힙 위반 노드 인덱스: {violations}")
    
    # 3) 좌표 계산 (horizontal_gap=60, vertical_gap=100, top_margin=50)
    positions = compute_positions(n, horizontal_gap=60, vertical_gap=100, top_margin=50)
    print(f"계산된 좌표 및 레벨 정보: {positions}")
    
    # 4) Animal Script(.asu) 생성
    output_filename = "heap31.asu"
    generate_animal_script(n, values, violations, positions, output_filename)
    print(f"Animal Script 파일이 '{output_filename}'로 생성되었습니다.")